"use client";

import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { PriceChart } from "./price-chart";
import { AIRecommendation } from "./ai-recommendation";
import { MarketContext } from "./market-context";
import { LoadingSpinner } from "./loading-spinner";
import { generatePriceSimulation, SimulationData } from "@/lib/price-simulator";
// Using Binance API for everything (current price + historical data)
import {
  fetchBinanceKlines,
  mapTimeframeToBinanceInterval,
  fetchBinanceCurrentPrice,
  FALLBACK_BTC_PRICE,
  Candlestick
} from "@/lib/binance-api";
// CoinGecko API (not used anymore)
// import { fetchBTCPrice, FALLBACK_BTC_PRICE } from "@/lib/btc-api";
// CoinMarketCap API (free tier doesn't support historical endpoint)
// import { fetchBTCHistoricalFromCMC, Candlestick } from "@/lib/coinmarketcap-api";
import { TrendingUp, TrendingDown, Activity, RefreshCw, ArrowLeft } from "lucide-react";
import Link from "next/link";
import { PredictionTracker, PredictionTracking } from "@/lib/prediction-tracker";
import { PredictionTrackingCard } from "./prediction-tracking-card";

export function BTCPredictor() {
  const [timeframe] = useState<"1week">("1week"); // Fixed to 1 week only
  const [simulationData, setSimulationData] = useState<SimulationData | null>(null);
  const [isSimulating, setIsSimulating] = useState(false);
  const [currentPrice, setCurrentPrice] = useState(FALLBACK_BTC_PRICE);
  const [isLoadingPrice, setIsLoadingPrice] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
  const [historicalData, setHistoricalData] = useState<Candlestick[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const [hasGenerated, setHasGenerated] = useState(false); // Track if prediction was generated
  const [trackingData, setTrackingData] = useState<PredictionTracking | null>(null);

  const tracker = new PredictionTracker();

  // Load saved prediction from localStorage on mount
  useEffect(() => {
    const savedPrediction = localStorage.getItem('btc_prediction');
    if (savedPrediction) {
      try {
        const data = JSON.parse(savedPrediction);
        setSimulationData(data);
        setHasGenerated(true);
        console.log('âœ… Loaded saved prediction from localStorage');
      } catch (error) {
        console.error('Error loading saved prediction:', error);
      }
    }
    
    // Load and update tracking data
    tracker.updateActualPrices().then(data => {
      if (data) {
        setTrackingData(data);
        console.log('âœ… Tracking data updated');
      }
    });
  }, []);

  // Fetch real-time BTC price from Binance
  const fetchPrice = async () => {
    setIsLoadingPrice(true);
    const price = await fetchBinanceCurrentPrice("BTCUSDT");
    if (price) {
      setCurrentPrice(price);
      setLastUpdated(new Date());
    }
    setIsLoadingPrice(false);
  };

  // Fetch historical data from Binance
  const fetchHistoricalData = async () => {
    setIsLoadingHistory(true);
    const interval = mapTimeframeToBinanceInterval(timeframe);
    console.log(`ðŸ“Š Fetching Binance data: interval=${interval}, limit=1000`);
    
    // Fetch maximum available data for backend AI analysis
    // Binance API limit: 1000 candles per request
    const data = await fetchBinanceKlines("BTCUSDT", interval, 1000);
    
    if (data.length > 0) {
      const firstCandle = data[0];
      const lastCandle = data[data.length - 1];
      const firstDate = new Date(firstCandle.time).toISOString().split('T')[0];
      const lastDate = new Date(lastCandle.time).toISOString().split('T')[0];
      const daysDiff = Math.round((lastCandle.time - firstCandle.time) / (1000 * 60 * 60 * 24));
      
      console.log(`âœ… Received ${data.length} candles`);
      console.log(`ðŸ“… Date range: ${firstDate} to ${lastDate}`);
      console.log(`â±ï¸  Total days: ${daysDiff} days`);
      console.log(`ðŸ’° First price: $${firstCandle.close.toLocaleString()}`);
      console.log(`ðŸ’° Last price: $${lastCandle.close.toLocaleString()}`);
    }
    
    setHistoricalData(data);
    setIsLoadingHistory(false);
  };

  // Initial price fetch and periodic updates
  useEffect(() => {
    fetchPrice();
    
    // Refresh price every 60 seconds
    const interval = setInterval(fetchPrice, 60000);
    
    return () => clearInterval(interval);
  }, []);

  // Fetch historical data when timeframe changes
  useEffect(() => {
    fetchHistoricalData();
  }, [timeframe]);

  // DON'T auto-run simulation - wait for user to click button
  // Remove the auto-run useEffect

  const runSimulation = async () => {
    if (historicalData.length === 0) return;
    
    // Clear existing data first (like page refresh)
    setSimulationData(null);
    setIsSimulating(true);
    
    try {
      // Force refresh to get new AI predictions from Gemini
      const data = await generatePriceSimulation(historicalData, currentPrice, timeframe, true);
      setSimulationData(data);
      
      // Save to localStorage for persistence
      localStorage.setItem('btc_prediction', JSON.stringify(data));
      setHasGenerated(true); // Hide button after generation
      
      console.log('âœ… Prediction generated and saved to localStorage');
      
      // Save prediction tracking
      if (data.chartData && data.aiConfidence) {
        const predictions = data.chartData
          .filter(d => !d.isHistorical)
          .map(d => d.price);
        
        if (predictions.length === 7) {
          const tracking = tracker.savePrediction(
            predictions,
            data.aiConfidence,
            data.aiTrend || "neutral"
          );
          setTrackingData(tracking);
          console.log('âœ… Prediction tracking saved');
        }
      }
    } catch (error) {
      console.error("Simulation error:", error);
    } finally {
      setIsSimulating(false);
    }
  };

  const priceChange = simulationData
    ? ((simulationData.predictedPrice - currentPrice) / currentPrice) * 100
    : 0;

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 via-purple-950 to-slate-950 p-4 sm:p-6 md:p-8">
      <div className="container mx-auto px-4 py-8 max-w-7xl">
        {/* Header */}
        <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-8 gap-4">
          <div className="flex items-center gap-3">
            <Link href="/">
              <Button
                variant="outline"
                size="icon"
                className="border-purple-500/30 hover:bg-purple-500/10"
              >
                <ArrowLeft className="w-5 h-5" />
              </Button>
            </Link>
            <div className="w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
              <Activity className="w-5 h-5 sm:w-6 sm:h-6 text-white" />
            </div>
            <div>
              <h1 className="text-xl sm:text-2xl md:text-3xl font-bold text-white">BTC Predictor</h1>
              <p className="text-xs sm:text-sm text-purple-300">
                Powered by MOT
              </p>
            </div>
          </div>
          <div className="flex items-center gap-3">
            <div className="text-right">
              <p className="text-xs text-gray-400">Last Updated</p>
              <p className="text-sm text-purple-300">
                {lastUpdated.toLocaleTimeString(undefined, {
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                })}
              </p>
            </div>
            <Button
              onClick={fetchPrice}
              disabled={isLoadingPrice}
              variant="outline"
              size="icon"
              className="border-purple-500/30 hover:bg-purple-500/10"
            >
              <RefreshCw className={`w-4 h-4 ${isLoadingPrice ? "animate-spin" : ""}`} />
            </Button>
          </div>
        </div>

      {/* Current Price Display */}
      <Card className="mb-6 bg-slate-900/50 border-purple-500/20 backdrop-blur-sm">
        <CardContent className="pt-6">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
            <div>
              <div className="flex items-center gap-2 mb-1">
                <p className="text-xs sm:text-sm text-gray-400">Current BTC Price</p>
                <div className="flex items-center gap-1">
                  <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                  <span className="text-xs text-green-500">Live</span>
                </div>
              </div>
              {isLoadingPrice ? (
                <div className="flex items-center gap-3">
                  <LoadingSpinner size="sm" />
                  <p className="text-xl text-gray-400">Loading...</p>
                </div>
              ) : (
                <p className="text-2xl sm:text-3xl md:text-4xl font-bold text-white">
                  ${currentPrice.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  })}
                </p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Price Chart - Only show when prediction exists */}
      {simulationData && (
        <Card className="mb-6 bg-slate-900/50 border-purple-500/20 backdrop-blur-sm">
          <CardHeader>
            <CardTitle className="text-white">Price Simulation</CardTitle>
          </CardHeader>
          <CardContent>
            <PriceChart data={simulationData.chartData} timeframe={timeframe} />
          </CardContent>
        </Card>
      )}

      {/* AI Recommendation */}
      {simulationData && (
        <AIRecommendation
          recommendation={simulationData.recommendation}
          priceChange={priceChange}
        />
      )}

      {/* Market Context */}
      {simulationData && (
        <MarketContext context={simulationData.marketContext} />
      )}

      {/* Prediction Tracking Card */}
      {trackingData && (
        <div className="mt-8 mb-6">
          <PredictionTrackingCard
            tracking={trackingData}
            overallAccuracy={tracker.calculateOverallAccuracy(trackingData)}
            completionStatus={tracker.getCompletionStatus(trackingData)}
          />
        </div>
      )}

      {/* Simulate Button - Only show if not generated yet */}
      {!hasGenerated && (
        <div className="mt-6 flex justify-center">
          <Button
            onClick={runSimulation}
            disabled={isSimulating || historicalData.length === 0}
            className="bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white px-6 sm:px-8 py-4 sm:py-6 text-base sm:text-lg w-full sm:w-auto"
          >
            {isSimulating ? (
              <span className="flex items-center gap-2">
                <LoadingSpinner size="sm" />
                Generating AI Prediction...
              </span>
            ) : (
              "Run New Simulation and Recommendation"
            )}
          </Button>
        </div>
      )}
      </div>
    </div>
  );
}
